name: Build and Release

on:
  push:
    tags:
      - 'v*'  # Trigger on version tags like v1.0.0
  workflow_dispatch:  # Allow manual trigger

env:
  VERSION: ${{ github.ref_name == 'refs/heads/main' && 'dev' || github.ref_name }}
  GO_VERSION: '1.23'

jobs:
  build-windows:
    name: Build Windows
    runs-on: windows-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install Wails CLI
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest

      - name: Install frontend dependencies
        working-directory: frontend
        run: npm install

      - name: Build frontend
        working-directory: frontend
        run: npm run build

      - name: Copy custom icons to build directory
        run: |
          mkdir -p build/windows
          copy assets\icons\icon.ico build\windows\icon.ico
          copy assets\icons\appicon.png build\appicon.png

      - name: Build Windows app
        run: wails build -platform windows/amd64

      - name: Upload Windows artifact
        uses: actions/upload-artifact@v4
        with:
          name: snaplog-windows-amd64
          path: build/bin/snaplog.exe
          retention-days: 30

  build-macos-intel:
    name: Build and Sign macOS (Intel)
    runs-on: macos-latest
    timeout-minutes: 30
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install Wails CLI
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest

      - name: Install frontend dependencies
        working-directory: frontend
        run: npm install

      - name: Build frontend
        working-directory: frontend
        run: npm run build

      - name: Copy custom icons to build directory
        run: |
          mkdir -p build/darwin
          cp assets/icons/appicon.png build/appicon.png
          if [ -f assets/icons/appicon.icns ]; then
            cp assets/icons/appicon.icns build/appicon.icns
          fi

      - name: Build macOS app (Intel)
        run: wails build -platform darwin/amd64

      - name: Import Developer ID certificate
        env:
          DEVELOPER_ID_CERT: ${{ secrets.DEVELOPER_ID_CERT }}
          DEVELOPER_ID_CERT_PASSWORD: ${{ secrets.DEVELOPER_ID_CERT_PASSWORD }}
        run: |
          echo "$DEVELOPER_ID_CERT" | base64 --decode > developer_id.p12
          security create-keychain -p "" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "" build.keychain
          security import developer_id.p12 -k build.keychain -P "$DEVELOPER_ID_CERT_PASSWORD" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain
          rm developer_id.p12

      - name: Sign app with codesign
        run: |
          codesign --force --deep --sign "Developer ID Application: Pritish Narendra Thombare (39B7GLKL6D)" \
            --entitlements assets/darwin/entitlements.plist \
            --options runtime \
            --timestamp \
            --keychain build.keychain \
            build/bin/snaplog.app

      - name: Verify code signature
        run: codesign --verify --verbose build/bin/snaplog.app

      - name: Verify entitlements are embedded
        run: |
          echo "Checking entitlements in signed app..."
          ENTITLEMENTS=$(codesign -d --entitlements - build/bin/snaplog.app 2>&1)
          if echo "$ENTITLEMENTS" | grep -q "com.apple.security.device.keyboard"; then
            echo "✓ Keyboard entitlement found"
          else
            echo "✗ ERROR: Keyboard entitlement NOT found!"
            exit 1
          fi
          if echo "$ENTITLEMENTS" | grep -q "com.apple.security.network.client"; then
            echo "✓ Network client entitlement found"
          else
            echo "✗ ERROR: Network client entitlement NOT found!"
            exit 1
          fi
          echo "All entitlements verified successfully"
          echo ""
          echo "Full entitlements:"
          echo "$ENTITLEMENTS"

      - name: Create notarization key file
        run: |
          echo "${{ secrets.NOTARY_P8_KEY }}" > notary_key.p8
          chmod 600 notary_key.p8

      - name: Zip app for notarization
        run: |
          cd build/bin
          zip -r snaplog.zip snaplog.app
          cd ../..

      - name: Submit for notarization
        id: notarize
        run: |
          SUBMIT_OUTPUT=$(xcrun notarytool submit build/bin/snaplog.zip \
            --key notary_key.p8 \
            --key-id "${{ secrets.NOTARY_KEY_ID }}" \
            --issuer "${{ secrets.NOTARY_ISSUER_ID }}" \
            --output-format json)
          
          SUBMISSION_ID=$(echo "$SUBMIT_OUTPUT" | jq -r '.id')
          echo "submission_id=$SUBMISSION_ID" >> $GITHUB_OUTPUT
          echo "::notice title=Notarization Submitted::Submission ID: $SUBMISSION_ID"
          echo "Notarization submitted. Submission ID: $SUBMISSION_ID"
          echo "This will be processed in a separate job."
          
          # Save submission ID to file for the next job
          echo "$SUBMISSION_ID" > submission_id.txt

      - name: Clean up notary key and zip
        if: always()
        run: |
          rm -f notary_key.p8
          rm -f build/bin/snaplog.zip

      - name: Clean up keychain
        if: always()
        run: |
          security delete-keychain build.keychain || true

      - name: Verify app exists before upload
        run: |
          echo "=== PRE-UPLOAD VERIFICATION ==="
          echo "Checking if build/bin/snaplog.app exists..."
          if [ ! -d "build/bin/snaplog.app" ]; then
            echo "ERROR: build/bin/snaplog.app does not exist!"
            echo "Contents of build/bin:"
            ls -la build/bin/ || echo "build/bin does not exist"
            exit 1
          fi
          echo "✓ build/bin/snaplog.app exists"
          echo "App bundle structure:"
          ls -la build/bin/snaplog.app/
          echo "Contents folder:"
          ls -la build/bin/snaplog.app/Contents/ || echo "Contents folder missing!"
          echo "App size:"
          du -sh build/bin/snaplog.app

      - name: Upload signed app (before notarization)
        uses: actions/upload-artifact@v4
        with:
          name: snaplog-macos-intel-signed
          path: build/bin/snaplog.app
          if-no-files-found: error
          retention-days: 7

      - name: Upload notarization submission ID
        uses: actions/upload-artifact@v4
        with:
          name: notarization-submission-id-intel
          path: submission_id.txt
          retention-days: 7

  build-macos-arm:
    name: Build and Sign macOS (ARM64)
    runs-on: macos-latest
    timeout-minutes: 30
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install Wails CLI
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest

      - name: Install frontend dependencies
        working-directory: frontend
        run: npm install

      - name: Build frontend
        working-directory: frontend
        run: npm run build

      - name: Copy custom icons to build directory
        run: |
          mkdir -p build/darwin
          cp assets/icons/appicon.png build/appicon.png
          if [ -f assets/icons/appicon.icns ]; then
            cp assets/icons/appicon.icns build/appicon.icns
          fi

      - name: Build macOS app (ARM64)
        run: wails build -platform darwin/arm64

      - name: Import Developer ID certificate
        env:
          DEVELOPER_ID_CERT: ${{ secrets.DEVELOPER_ID_CERT }}
          DEVELOPER_ID_CERT_PASSWORD: ${{ secrets.DEVELOPER_ID_CERT_PASSWORD }}
        run: |
          echo "$DEVELOPER_ID_CERT" | base64 --decode > developer_id.p12
          security create-keychain -p "" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "" build.keychain
          security import developer_id.p12 -k build.keychain -P "$DEVELOPER_ID_CERT_PASSWORD" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain
          rm developer_id.p12

      - name: Sign app with codesign
        run: |
          codesign --force --deep --sign "Developer ID Application: Pritish Narendra Thombare (39B7GLKL6D)" \
            --entitlements assets/darwin/entitlements.plist \
            --options runtime \
            --timestamp \
            --keychain build.keychain \
            build/bin/snaplog.app

      - name: Verify code signature
        run: codesign --verify --verbose build/bin/snaplog.app

      - name: Create notarization key file
        run: |
          echo "${{ secrets.NOTARY_P8_KEY }}" > notary_key.p8
          chmod 600 notary_key.p8

      - name: Verify jq is available
        run: |
          if ! command -v jq &> /dev/null; then
            echo "jq is not installed, installing..."
            brew install jq
          fi
          jq --version

      - name: Zip app for notarization
        run: |
          cd build/bin
          zip -r snaplog-arm.zip snaplog.app
          cd ../..

      - name: Submit for notarization
        id: notarize
        run: |
          SUBMIT_OUTPUT=$(xcrun notarytool submit build/bin/snaplog-arm.zip \
            --key notary_key.p8 \
            --key-id "${{ secrets.NOTARY_KEY_ID }}" \
            --issuer "${{ secrets.NOTARY_ISSUER_ID }}" \
            --output-format json)
          
          SUBMISSION_ID=$(echo "$SUBMIT_OUTPUT" | jq -r '.id')
          echo "submission_id=$SUBMISSION_ID" >> $GITHUB_OUTPUT
          echo "::notice title=Notarization Submitted::Submission ID: $SUBMISSION_ID"
          echo "Notarization submitted. Submission ID: $SUBMISSION_ID"
          echo "This will be processed in a separate job."
          
          # Save submission ID to file for the next job
          echo "$SUBMISSION_ID" > submission_id.txt

      - name: Clean up notary key and zip
        if: always()
        run: |
          rm -f notary_key.p8
          rm -f build/bin/snaplog-arm.zip

      - name: Clean up keychain
        if: always()
        run: |
          security delete-keychain build.keychain || true

      - name: Verify app exists before upload
        run: |
          echo "=== PRE-UPLOAD VERIFICATION ==="
          echo "Checking if build/bin/snaplog.app exists..."
          if [ ! -d "build/bin/snaplog.app" ]; then
            echo "ERROR: build/bin/snaplog.app does not exist!"
            echo "Contents of build/bin:"
            ls -la build/bin/ || echo "build/bin does not exist"
            exit 1
          fi
          echo "✓ build/bin/snaplog.app exists"
          echo "App bundle structure:"
          ls -la build/bin/snaplog.app/
          echo "Contents folder:"
          ls -la build/bin/snaplog.app/Contents/ || echo "Contents folder missing!"
          echo "App size:"
          du -sh build/bin/snaplog.app

      - name: Upload signed app (before notarization)
        uses: actions/upload-artifact@v4
        with:
          name: snaplog-macos-arm-signed
          path: build/bin/snaplog.app
          if-no-files-found: error
          retention-days: 7

      - name: Upload notarization submission ID
        uses: actions/upload-artifact@v4
        with:
          name: notarization-submission-id-arm
          path: submission_id.txt
          retention-days: 7

  notarize-macos-intel:
    name: Notarize and Package macOS (Intel)
    runs-on: macos-latest
    needs: build-macos-intel
    timeout-minutes: 1800  # 30 hours max
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download signed app
        uses: actions/download-artifact@v4
        with:
          name: snaplog-macos-intel-signed
          path: temp-download

      - name: Debug downloaded artifact structure
        run: |
          echo "=== POST-DOWNLOAD DEBUG ==="
          echo "Current working directory:"
          pwd
          echo ""
          echo "Contents of temp-download:"
          ls -la temp-download/ || echo "temp-download does not exist"
          echo ""
          echo "Full directory tree of temp-download:"
          find temp-download -type d 2>/dev/null | head -20 || echo "No directories found"
          echo ""
          echo "All .app bundles found:"
          find temp-download -type d -name "*.app" 2>/dev/null || echo "No .app bundles found"
          echo ""
          echo "All files and directories recursively:"
          find temp-download -maxdepth 3 2>/dev/null || echo "Cannot traverse"
          echo ""
          echo "Checking for Contents folders:"
          find temp-download -type d -name "Contents" 2>/dev/null || echo "No Contents folders found"

      - name: Move app to build/bin
        run: |
          echo "=== MOVING APP TO build/bin ==="
          mkdir -p build/bin
          
          APP_FOUND=false
          APP_SOURCE=""
          
          # Check all possible locations
          echo "Checking possible locations..."
          
          if [ -d "temp-download/build/bin/snaplog.app" ]; then
            echo "✓ Found: temp-download/build/bin/snaplog.app"
            APP_SOURCE="temp-download/build/bin/snaplog.app"
            APP_FOUND=true
          elif [ -d "temp-download/snaplog.app" ]; then
            echo "✓ Found: temp-download/snaplog.app"
            APP_SOURCE="temp-download/snaplog.app"
            APP_FOUND=true
          elif [ -d "temp-download/build/bin" ] && [ -d "temp-download/build/bin/Contents" ]; then
            echo "⚠ Found extracted Contents in temp-download/build/bin/"
            echo "Reconstructing .app bundle..."
            mkdir -p temp-download/snaplog.app
            mv temp-download/build/bin/* temp-download/snaplog.app/ 2>/dev/null || true
            APP_SOURCE="temp-download/snaplog.app"
            APP_FOUND=true
          elif [ -d "temp-download/Contents" ]; then
            echo "⚠ Found extracted Contents in temp-download/"
            echo "Reconstructing .app bundle..."
            mkdir -p temp-download/snaplog.app
            mv temp-download/* temp-download/snaplog.app/ 2>/dev/null || true
            APP_SOURCE="temp-download/snaplog.app"
            APP_FOUND=true
          else
            echo "✗ ERROR: Could not find snaplog.app in any expected location"
            echo ""
            echo "Full search results:"
            find temp-download -type d 2>/dev/null
            exit 1
          fi
          
          if [ "$APP_FOUND" = true ]; then
            echo "Copying from $APP_SOURCE to build/bin/snaplog.app"
            cp -R "$APP_SOURCE" build/bin/
            
            echo "Verifying copied app..."
            if [ ! -d "build/bin/snaplog.app" ]; then
              echo "✗ ERROR: Copy failed - build/bin/snaplog.app does not exist"
              exit 1
            fi
            
            if [ ! -d "build/bin/snaplog.app/Contents" ]; then
              echo "✗ ERROR: build/bin/snaplog.app is not a valid .app bundle (missing Contents/)"
              echo "Contents of build/bin/snaplog.app:"
              ls -la build/bin/snaplog.app/
              exit 1
            fi
            
            echo "✓ App successfully located and verified at: build/bin/snaplog.app"
            echo "APP_PATH=build/bin/snaplog.app" >> $GITHUB_ENV
          fi

      - name: Download notarization submission ID
        uses: actions/download-artifact@v4
        with:
          name: notarization-submission-id-intel
          path: .

      - name: Get notarization submission ID
        id: get-id
        run: |
          # Download submission ID from previous job
          mkdir -p submission
          # Try to get from artifact first
          if [ -f submission_id.txt ]; then
            SUBMISSION_ID=$(cat submission_id.txt)
          else
            # Fallback: try to get from job outputs (may not work across jobs)
            SUBMISSION_ID="${{ needs.build-macos-intel.outputs.submission_id }}"
          fi
          
          if [ -z "$SUBMISSION_ID" ] || [ "$SUBMISSION_ID" = "" ] || [ "$SUBMISSION_ID" = "null" ]; then
            echo "ERROR: No submission ID found"
            exit 1
          fi
          
          echo "submission_id=$SUBMISSION_ID" >> $GITHUB_OUTPUT
          echo "Waiting for notarization: $SUBMISSION_ID"

      - name: Create notarization key file
        run: |
          echo "${{ secrets.NOTARY_P8_KEY }}" > notary_key.p8
          chmod 600 notary_key.p8

      - name: Verify jq is available
        run: |
          if ! command -v jq &> /dev/null; then
            echo "jq is not installed, installing..."
            brew install jq
          fi
          jq --version

      - name: Wait for notarization
        id: wait
        timeout-minutes: 1800  # 30 hours max
        run: |
          SUBMISSION_ID=$(cat submission_id.txt)
          MAX_WAIT=108000  # 30 hours in seconds
          ELAPSED=0
          INTERVAL=180  # Check every 3 minutes
          
          echo "Waiting for notarization to complete..."
          echo "Submission ID: $SUBMISSION_ID"
          
          if [ -z "$SUBMISSION_ID" ] || [ "$SUBMISSION_ID" = "" ]; then
            echo "ERROR: Submission ID is empty!"
            exit 1
          fi
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            # Get status with error handling
            set +e  # Don't exit on error
            STATUS_OUTPUT=$(xcrun notarytool log \
              --key notary_key.p8 \
              --key-id "${{ secrets.NOTARY_KEY_ID }}" \
              --issuer "${{ secrets.NOTARY_ISSUER_ID }}" \
              "$SUBMISSION_ID" \
              --output-format json 2>&1)
            NOTARY_EXIT_CODE=$?
            set -e  # Re-enable exit on error
            
            if [ $NOTARY_EXIT_CODE -ne 0 ]; then
              echo "Warning: notarytool log failed (exit code $NOTARY_EXIT_CODE)"
              echo "Output: $STATUS_OUTPUT"
              echo "This might be normal if notarization just started. Retrying in $INTERVAL seconds..."
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
              continue
            fi
            
            # Try to parse status
            STATUS=$(echo "$STATUS_OUTPUT" | jq -r '.status // "Unknown"' 2>/dev/null || echo "Unknown")
            
            if [ "$STATUS" = "Unknown" ]; then
              echo "Could not parse status from output:"
              echo "$STATUS_OUTPUT"
              echo "Retrying in $INTERVAL seconds..."
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
              continue
            fi
            
            echo "[$(date +%H:%M:%S)] Status: $STATUS (${ELAPSED}s elapsed)"
            
            case "$STATUS" in
              "Accepted")
                echo "✓ Notarization succeeded!"
                exit 0
                ;;
              "Invalid"|"Rejected")
                echo "✗ Notarization failed!"
                echo "Full log:"
                echo "$STATUS_OUTPUT"
                exit 1
                ;;
              "In Progress"|"Pending")
                echo "Still processing..."
                ;;
              *)
                echo "Status: $STATUS (continuing to wait...)"
                ;;
            esac
            
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          echo "✗ Notarization timed out after 30 hours"
          exit 1

      - name: Staple notarization
        run: xcrun stapler staple "$APP_PATH"

      - name: Verify notarization
        run: xcrun stapler validate "$APP_PATH"

      - name: Clean up notary key
        if: always()
        run: rm -f notary_key.p8

      - name: Create DMG
        run: |
          hdiutil create -volname "SnapLog" -srcfolder "$APP_PATH" -ov -format UDZO snaplog.dmg

      - name: Upload notarized macOS artifact (Intel)
        uses: actions/upload-artifact@v4
        with:
          name: snaplog-macos-amd64
          path: |
            build/bin/snaplog.app
            snaplog.dmg
          retention-days: 30

  notarize-macos-arm:
    name: Notarize and Package macOS (ARM64)
    runs-on: macos-latest
    needs: build-macos-arm
    timeout-minutes: 1800
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download signed app
        uses: actions/download-artifact@v4
        with:
          name: snaplog-macos-arm-signed
          path: temp-download

      - name: Debug downloaded artifact structure
        run: |
          echo "=== POST-DOWNLOAD DEBUG ==="
          echo "Current working directory:"
          pwd
          echo ""
          echo "Contents of temp-download:"
          ls -la temp-download/ || echo "temp-download does not exist"
          echo ""
          echo "Full directory tree of temp-download:"
          find temp-download -type d 2>/dev/null | head -20 || echo "No directories found"
          echo ""
          echo "All .app bundles found:"
          find temp-download -type d -name "*.app" 2>/dev/null || echo "No .app bundles found"
          echo ""
          echo "All files and directories recursively:"
          find temp-download -maxdepth 3 2>/dev/null || echo "Cannot traverse"
          echo ""
          echo "Checking for Contents folders:"
          find temp-download -type d -name "Contents" 2>/dev/null || echo "No Contents folders found"

      - name: Move app to build/bin
        run: |
          echo "=== MOVING APP TO build/bin ==="
          mkdir -p build/bin
          
          APP_FOUND=false
          APP_SOURCE=""
          
          # Check all possible locations
          echo "Checking possible locations..."
          
          if [ -d "temp-download/build/bin/snaplog.app" ]; then
            echo "✓ Found: temp-download/build/bin/snaplog.app"
            APP_SOURCE="temp-download/build/bin/snaplog.app"
            APP_FOUND=true
          elif [ -d "temp-download/snaplog.app" ]; then
            echo "✓ Found: temp-download/snaplog.app"
            APP_SOURCE="temp-download/snaplog.app"
            APP_FOUND=true
          elif [ -d "temp-download/build/bin" ] && [ -d "temp-download/build/bin/Contents" ]; then
            echo "⚠ Found extracted Contents in temp-download/build/bin/"
            echo "Reconstructing .app bundle..."
            mkdir -p temp-download/snaplog.app
            mv temp-download/build/bin/* temp-download/snaplog.app/ 2>/dev/null || true
            APP_SOURCE="temp-download/snaplog.app"
            APP_FOUND=true
          elif [ -d "temp-download/Contents" ]; then
            echo "⚠ Found extracted Contents in temp-download/"
            echo "Reconstructing .app bundle..."
            mkdir -p temp-download/snaplog.app
            mv temp-download/* temp-download/snaplog.app/ 2>/dev/null || true
            APP_SOURCE="temp-download/snaplog.app"
            APP_FOUND=true
          else
            echo "✗ ERROR: Could not find snaplog.app in any expected location"
            echo ""
            echo "Full search results:"
            find temp-download -type d 2>/dev/null
            exit 1
          fi
          
          if [ "$APP_FOUND" = true ]; then
            echo "Copying from $APP_SOURCE to build/bin/snaplog.app"
            cp -R "$APP_SOURCE" build/bin/
            
            echo "Verifying copied app..."
            if [ ! -d "build/bin/snaplog.app" ]; then
              echo "✗ ERROR: Copy failed - build/bin/snaplog.app does not exist"
              exit 1
            fi
            
            if [ ! -d "build/bin/snaplog.app/Contents" ]; then
              echo "✗ ERROR: build/bin/snaplog.app is not a valid .app bundle (missing Contents/)"
              echo "Contents of build/bin/snaplog.app:"
              ls -la build/bin/snaplog.app/
              exit 1
            fi
            
            echo "✓ App successfully located and verified at: build/bin/snaplog.app"
            echo "APP_PATH=build/bin/snaplog.app" >> $GITHUB_ENV
          fi

      - name: Download notarization submission ID
        uses: actions/download-artifact@v4
        with:
          name: notarization-submission-id-arm
          path: .

      - name: Get notarization submission ID
        id: get-id
        run: |
          # Download submission ID from previous job
          mkdir -p submission
          # Try to get from artifact first
          if [ -f submission_id.txt ]; then
            SUBMISSION_ID=$(cat submission_id.txt)
          else
            # Fallback: try to get from job outputs (may not work across jobs)
            SUBMISSION_ID="${{ needs.build-macos-arm.outputs.submission_id }}"
          fi
          
          if [ -z "$SUBMISSION_ID" ] || [ "$SUBMISSION_ID" = "" ] || [ "$SUBMISSION_ID" = "null" ]; then
            echo "ERROR: No submission ID found"
            exit 1
          fi
          
          echo "submission_id=$SUBMISSION_ID" >> $GITHUB_OUTPUT
          echo "Waiting for notarization: $SUBMISSION_ID"

      - name: Create notarization key file
        run: |
          echo "${{ secrets.NOTARY_P8_KEY }}" > notary_key.p8
          chmod 600 notary_key.p8

      - name: Verify jq is available
        run: |
          if ! command -v jq &> /dev/null; then
            echo "jq is not installed, installing..."
            brew install jq
          fi
          jq --version

      - name: Wait for notarization
        id: wait
        timeout-minutes: 1800  # 30 hours max
        run: |
          SUBMISSION_ID=$(cat submission_id.txt)
          MAX_WAIT=108000  # 30 hours in seconds
          ELAPSED=0
          INTERVAL=180  # Check every 3 minutes
          
          echo "Waiting for notarization to complete..."
          echo "Submission ID: $SUBMISSION_ID"
          
          if [ -z "$SUBMISSION_ID" ] || [ "$SUBMISSION_ID" = "" ]; then
            echo "ERROR: Submission ID is empty!"
            exit 1
          fi
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            # Get status with error handling
            set +e  # Don't exit on error
            STATUS_OUTPUT=$(xcrun notarytool log \
              --key notary_key.p8 \
              --key-id "${{ secrets.NOTARY_KEY_ID }}" \
              --issuer "${{ secrets.NOTARY_ISSUER_ID }}" \
              "$SUBMISSION_ID" \
              --output-format json 2>&1)
            NOTARY_EXIT_CODE=$?
            set -e  # Re-enable exit on error
            
            if [ $NOTARY_EXIT_CODE -ne 0 ]; then
              echo "Warning: notarytool log failed (exit code $NOTARY_EXIT_CODE)"
              echo "Output: $STATUS_OUTPUT"
              echo "This might be normal if notarization just started. Retrying in $INTERVAL seconds..."
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
              continue
            fi
            
            # Try to parse status
            STATUS=$(echo "$STATUS_OUTPUT" | jq -r '.status // "Unknown"' 2>/dev/null || echo "Unknown")
            
            if [ "$STATUS" = "Unknown" ]; then
              echo "Could not parse status from output:"
              echo "$STATUS_OUTPUT"
              echo "Retrying in $INTERVAL seconds..."
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
              continue
            fi
            
            echo "[$(date +%H:%M:%S)] Status: $STATUS (${ELAPSED}s elapsed)"
            
            case "$STATUS" in
              "Accepted")
                echo "✓ Notarization succeeded!"
                exit 0
                ;;
              "Invalid"|"Rejected")
                echo "✗ Notarization failed!"
                echo "Full log:"
                echo "$STATUS_OUTPUT"
                exit 1
                ;;
              "In Progress"|"Pending")
                echo "Still processing..."
                ;;
              *)
                echo "Status: $STATUS (continuing to wait...)"
                ;;
            esac
            
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          echo "✗ Notarization timed out after 30 hours"
          exit 1

      - name: Staple notarization
        run: xcrun stapler staple "$APP_PATH"

      - name: Verify notarization
        run: xcrun stapler validate "$APP_PATH"

      - name: Clean up notary key
        if: always()
        run: rm -f notary_key.p8

      - name: Create DMG
        run: |
          hdiutil create -volname "SnapLog" -srcfolder "$APP_PATH" -ov -format UDZO snaplog-arm64.dmg

      - name: Upload notarized macOS artifact (ARM64)
        uses: actions/upload-artifact@v4
        with:
          name: snaplog-macos-arm64
          path: |
            build/bin/snaplog.app
            snaplog-arm64.dmg
          retention-days: 30

  release:
    name: Create Release
    needs: [build-windows, notarize-macos-intel, notarize-macos-arm]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get release tag
        id: get-tag
        run: |
          TAG=${GITHUB_REF#refs/tags/}
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Creating/updating release for tag: $TAG"

      - name: Download Windows artifact
        uses: actions/download-artifact@v4
        with:
          name: snaplog-windows-amd64
          path: dist/windows

      - name: Download macOS notarized artifacts (Intel)
        uses: actions/download-artifact@v4
        with:
          name: snaplog-macos-amd64
          path: dist/macos-intel

      - name: Download macOS notarized artifacts (ARM64)
        uses: actions/download-artifact@v4
        with:
          name: snaplog-macos-arm64
          path: dist/macos-arm64

      - name: Prepare release files
        run: |
          mkdir -p dist/release
          
          # Copy Windows executable
          if [ -f dist/windows/snaplog.exe ]; then
            cp dist/windows/snaplog.exe dist/release/snaplog.exe
            echo "✓ Windows executable copied"
          else
            echo "⚠ Warning: Windows executable not found"
          fi
          
          # Copy Intel macOS app and DMG
          if [ -d dist/macos-intel/snaplog.app ]; then
            echo "Including Intel macOS app"
            cp -r dist/macos-intel/snaplog.app dist/release/snaplog-intel.app
            echo "✓ Intel macOS app copied"
          else
            echo "⚠ Warning: Intel macOS app not found"
          fi
          
          if [ -f dist/macos-intel/snaplog.dmg ]; then
            cp dist/macos-intel/snaplog.dmg dist/release/snaplog-intel.dmg
            echo "✓ Intel macOS DMG copied"
          else
            echo "⚠ Warning: Intel macOS DMG not found"
          fi
          
          # Copy ARM64 macOS app and DMG
          if [ -d dist/macos-arm64/snaplog.app ]; then
            echo "Including ARM64 macOS app"
            cp -r dist/macos-arm64/snaplog.app dist/release/snaplog-arm64.app
            echo "✓ ARM64 macOS app copied"
          else
            echo "⚠ Warning: ARM64 macOS app not found"
          fi
          
          if [ -f dist/macos-arm64/snaplog-arm64.dmg ]; then
            cp dist/macos-arm64/snaplog-arm64.dmg dist/release/snaplog-arm64.dmg
            echo "✓ ARM64 macOS DMG copied"
          else
            echo "⚠ Warning: ARM64 macOS DMG not found"
          fi
          
          echo ""
          echo "Release files prepared:"
          ls -lh dist/release/

      - name: Delete existing release if present
        run: |
          TAG=${{ steps.get-tag.outputs.tag }}
          echo "Checking for existing release with tag: $TAG"
          
          # Get release ID if it exists using GitHub API
          RELEASE_RESPONSE=$(curl -s -w "\n%{http_code}" \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$TAG")
          
          HTTP_CODE=$(echo "$RELEASE_RESPONSE" | tail -n1)
          RELEASE_BODY=$(echo "$RELEASE_RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" = "200" ] && [ -n "$RELEASE_BODY" ]; then
            # Extract release ID using jq if available, otherwise use grep/sed
            if command -v jq &> /dev/null; then
              RELEASE_ID=$(echo "$RELEASE_BODY" | jq -r '.id // empty')
            else
              RELEASE_ID=$(echo "$RELEASE_BODY" | grep -o '"id":[[:space:]]*[0-9]*' | head -1 | grep -o '[0-9]*')
            fi
            
            if [ -n "$RELEASE_ID" ] && [ "$RELEASE_ID" != "null" ]; then
              echo "Found existing release (ID: $RELEASE_ID), deleting it..."
              DELETE_RESPONSE=$(curl -s -w "\n%{http_code}" -X DELETE \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                "https://api.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID")
              DELETE_CODE=$(echo "$DELETE_RESPONSE" | tail -n1)
              if [ "$DELETE_CODE" = "204" ]; then
                echo "✓ Existing release deleted successfully"
              else
                echo "⚠ Warning: Delete returned status $DELETE_CODE"
              fi
            else
              echo "Could not extract release ID from response"
            fi
          else
            echo "No existing release found for tag $TAG (HTTP $HTTP_CODE)"
          fi
        continue-on-error: true

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.get-tag.outputs.tag }}
          files: dist/release/*
          generate_release_notes: true
          body: |
            ## Downloads
            
            - **Windows**: `snaplog.exe` (unsigned)
            - **macOS Intel**: `snaplog-intel.app` and `snaplog-intel.dmg` (for Intel Macs)
            - **macOS ARM64**: `snaplog-arm64.app` and `snaplog-arm64.dmg` (for Apple Silicon Macs)
            
            > **Note**: Both macOS builds are notarized and ready to use.
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

